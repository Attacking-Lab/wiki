# ECSC 2024 Scoring Formula

<div class=page-badges>
<a href="https://github.com/attacking-lab/scoring-playground" class=badge-formula></a>
<a href="https://github.com/attacking-lab/scoring-playground" class=badge-dataset></a>
</div>

Scoring formula for the
[European Cybersecurity Challenge 2024](https://ecsc2024.it/) A/D CTF.
<div style="margin-bottom:-1em"></div>


## Summary

The total score of each team is calculated using a
(pseudo) [zero-sum](https://en.wikipedia.org/wiki/Zero-sum_game) scheme,
where each team begins the CTF with the same, non-zero amount of points, and
exploited teams *redistribute* a portion of their points to the attackers.

The following Python pseudo-code captures the team scores calculation:

``` python3
SCALE = 15 * sqrt(5)
NORM = log(log(5)) / 12
BASE = 5000

def score(teams: list[str]):
    # Initialize (partial) scores
    score = {team: {} for team in teams}
    sla = {team: {} for team in teams}
    attack = {team: {} for team in teams}
    defense = {team: {} for team in teams}
    for team in teams:
        score[team] = {service: BASE for service in services}
        attack[team] = {service: 0 for service in services}
        defense[team] = {service: 0 for service in services}
        sla[team] = {service: 0 for service in services}

    # Redistribute points based on attacks
    for rnd in rounds:
        for flag, attacker, victim in flags_stolen_in_round(rnd):
            for service in services:
                for _ in flags_stolen_from(team, service, rnd):
                    value = (1 + exp(NORM * (sqrt(score[attacker][service]) \
                          - sqrt(score[victim][service])))) * SCALE
                    attack[attacker][service] += value
                    defense[victim][service] += min(score[team][service], value)
        for team in teams:
            for service in services:
                score[team][service] = BASE + attack[team][service] \
                            - defense[team][service]

    # Accumulate score, weighted by SLA
    total = {team: 0 for team in teams}
    for team in teams:
        for service in services:
            sla_weight = sla[team][service] / len(rounds)
            total[team] += max(0, sla_weight * score[team][service])

    return total
```

Note how `score[team][service]` is recalculated each round and *may turn negative*,
although the total score `total[team]` can not.


## Review

- Difficult to reason about and does not deduce constants/formula logically
- SLA is a multiplicative factor to the attack/defense score; this violates
  [Tenet 5](../tenets/#the_cost_of_downtime_must_not_outweigh_the_benefits_of_patching) since a large amount of attack points may be lost through downtime, which are not outweighed by the saved defense points.
- Flags do not lose value based on the amount of successful attacks,
  violating [Tenet 3](../tenets/#flag_value_must_diminish_with_more_successful_attacks)
- Since the score gained from an attack scales exponentially with the
  difference of squares in the position, the formula may incentivize
  reaching a low scoreboard position while hoarding exploits in the early game
  before deploying all of them at once in a sort of 'rubber banding' strategy.


## Tenets

1. {{ tenet1_ecsc2024 }}
2. {{ tenet2_ecsc2024 }}
3. {{ tenet3_ecsc2024 }}
4. {{ tenet4_ecsc2024 }}
5. {{ tenet5_ecsc2024 }}
6. {{ tenet6_ecsc2024 }}
7. {{ tenet7_ecsc2024 }}
